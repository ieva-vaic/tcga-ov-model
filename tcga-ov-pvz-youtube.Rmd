---
title: "second tcga random example"
author: "Ieva"
date: "2023-07-03"
output: html_document
---
# created pagal: https://www.costalab.org/wp-content/uploads/2020/11/R_class_D3.html#5_Survival_Analysis
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r, echo=FALSE}
# Load packages
library("TCGAbiolinks")
library("caret")
library("limma")
library("edgeR")
library("glmnet")
library("factoextra")
library("FactoMineR")
library("caret")
library("SummarizedExperiment")
library("gplots")
library("survival")
library("survminer")
library("RColorBrewer")
library("gProfileR")
library("genefilter")
library("ggplot2")
```
```{r}
#set path
setwd("~/tcga-ov-data")
tcga_data = readRDS(file = "tcga_data.RDS")  
train_y <- read.csv("train_data.csv" )
```

## RNAseq norm via limma
```{r}
limma_pipeline = function(
  tcga_data,
  condition_variable,
  reference_group=NULL){

  design_factor = colData(tcga_data)[, condition_variable, drop=T]

  group = factor(design_factor)
  if(!is.null(reference_group)){group = relevel(group, ref=reference_group)}

  design = model.matrix(~ group)

  dge = DGEList(counts=assay(tcga_data),
                 samples=colData(tcga_data),
                 genes=as.data.frame(rowData(tcga_data)))

  # filtering
  keep = filterByExpr(dge,design)
  dge = dge[keep,,keep.lib.sizes=FALSE]
  rm(keep)

  # Normalization (TMM followed by voom)
  dge = calcNormFactors(dge)
  v = voom(dge, design, plot=TRUE)

  # Fit model to data given design
  fit = lmFit(v, design)
  fit = eBayes(fit)

  # Show top genes
  topGenes = topTable(fit, coef=ncol(design), number=100, sort.by="p")

  return(
    list(
      voomObj=v, # normalized data
      fit=fit, # fitted model and statistics
      topGenes=topGenes # the 100 most differentially expressed genes
    )
  )
}
```
```{r}

#applying limma
limma_res = limma_pipeline(
  tcga_data=tcga_data,
  condition_variable="vital_status",
  reference_group="Alive"
)

# Save the data as a file, if you need it later, you can just load this file
# instead of having to run the whole pipeline again
saveRDS(object = limma_res,
        file = "limma_res.RDS",
        compress = FALSE)
```

```{r}
#visualization function
plot_PCA = function(voomObj, condition_variable){
  group = factor(voomObj$targets[, condition_variable])
  pca = prcomp(t(voomObj$E))
  # Take PC1 and PC2 for the plot
  plot(pca$x[,1:2],col=group, pch=19)
  # include a legend for points
  legend("bottomleft", inset=.01, levels(group), pch=19, col=1:length(levels(group)))
  return(pca)
}
#actual visualization
res_pca = plot_PCA(limma_res$voomObj, "vital_status")
```
##Classification models: simple linear model (with feature selection), and then an Elastic Net model
```{r}
# Transpose and make it into a matrix object
d_mat = as.matrix(t(limma_res$voomObj$E))

# As before, we want this to be a factor
d_resp = as.factor(limma_res$voomObj$targets$vital_status)

# Divide data into training and testing set

# Set (random-number-generator) seed so that results are consistent between runs
set.seed(42)
train_ids = createDataPartition(d_resp, p=0.75, list=FALSE)

x_train = d_mat[train_ids, ]
x_test  = d_mat[-train_ids, ]

y_train = d_resp[train_ids]
y_test  = d_resp[-train_ids]
```
```{r}
#parameter alpha: Elastic Net will behave more like LASSO (alpha = 1) or like Ridge Regression (alpha = 0)
# Train model on training dataset using cross-validation
res = cv.glmnet(
  x = x_train,
  y = y_train,
  alpha = 0.5,
  family = "binomial"
)
```
```{r}
# Test/Make prediction on test dataset
y_pred = predict(res, newx=x_test, type="class", s="lambda.min")
confusion_matrix = table(y_pred, y_test)

# Evaluation statistics
print(confusion_matrix)

print(paste0("Sensitivity: ",sensitivity(confusion_matrix)))
print(paste0("Specificity: ",specificity(confusion_matrix)))
print(paste0("Precision: ",precision(confusion_matrix)))
```
```{r}
# Getting genes that contribute for the prediction
res_coef = coef(res, s="lambda.min") # the "coef" function returns a sparse matrix
dim(res_coef)
head(res_coef) # in a sparse matrix the "." represents the value of zero
# get coefficients with non-zero values
res_coef = res_coef[res_coef[,1] != 0,]
# note how performing this operation changed the type of the variable
head(res_coef)
# remove first coefficient as this is the intercept, a variable of the model itself
res_coef = res_coef[-1]

relevant_genes = names(res_coef) # get names of the (non-zero) variables.
length(relevant_genes) # number of selected genes
head(relevant_genes) # few select genes
head(limma_res$voomObj$genes)
```
```{r}
relevant_gene_names = limma_res$voomObj$genes[relevant_genes,"gene_name"] #čia man reikėjo pakeist nes neatitiko gene name stulpelis pvz stulpelio

head(relevant_gene_names) # few select genes (with readable names now)
```
```{r}
print(intersect(limma_res$topGenes$gene_id, relevant_genes))  #čia ir nesitikėt daug persidengimo, ensemble_gene_id keist i gene_id

```
########
# Clustering
```{r}
 # define the color palette for the plot
hmcol = colorRampPalette(rev(brewer.pal(9, "RdBu")))(256)

# perform complete linkage clustering
clust = function(x) hclust(x, method="complete")
# use the inverse of correlation as distance.
dist = function(x) as.dist((1-cor(t(x)))/2)

# Show green color for genes that also show up in DE analysis
colorLimmaGenes = ifelse(
  # Given a vector of boolean values
  (relevant_genes %in% limma_res$topGenes$gene_id),
  "green", # if true, return green for that value
  "white" # if false, return white for that value
)

# As you've seen a good looking heatmap involves a lot of parameters: does not work
gene_heatmap = heatmap.2(
  t(d_mat[,relevant_genes]),
  scale="row",          # scale the values for each gene (row)
  density.info="none",  # turns off density plot inside color legend
  trace="none",         # turns off trace lines inside the heat map
  col=hmcol,            # define the color map
  labRow=relevant_gene_names, # use gene names instead of ensembl annotation
  RowSideColors=colorLimmaGenes,
  labCol=FALSE,         # Not showing column labels
  ColSideColors=as.character(as.numeric(d_resp)), # Show colors for each response class
  dendrogram="both",    # Show dendrograms for both axis
  hclust = clust,       # Define hierarchical clustering method
  distfun = dist,       # Using correlation coefficient for distance function
  cexRow=.6,            # Resize row labels
  margins=c(2,6)        # Define margin spaces
)

```

```{r}
# Using the same method as in Day-2, get the dendrogram from the heatmap
# and cut it to get the 2 classes of genes

# Extract the hierarchical cluster from heatmap to class "hclust"
hc = as.hclust(gene_heatmap$rowDendrogram)

# Cut the tree into 2 groups, up-regulated in tumor and up-regulated in control
clusters = cutree(hc, k=2)
table(clusters)
```
```{r}
# selecting just a few columns so that its easier to visualize the table
gprofiler_cols = c("significant","p.value","overlap.size","term.id","term.name")

# make sure the URL uses https
set_base_url("https://biit.cs.ut.ee/gprofiler")

# Group 1, up in tumor
gprofiler(names(clusters[clusters %in% 1]))[, gprofiler_cols] 
#using g-profiler does not work, tačiau nuėjus į puslapį ir sukėlus ensg pavadinimus be "" ir be .XX (genus, ne transkriptus reik dėt), rodo GO analizę
```
```{r}
#mano nesamones padaryt kad go darytu
cluster1 <- names(clusters[clusters %in% 1])
cluster1 <- gsub("\\..*","",cluster1)
cluster2 <- names(clusters[clusters %in% 2])
cluster2 <- gsub("\\..*","",cluster2)

#tada susikeliu i exeli, pašalinu " ir analizuoju:https://biit.cs.ut.ee/gprofiler/gost
```

```{r}
#varience filtering to reduce dimensions
# retain only a small subset of the genes (see documentation for ?varFilter)
d_mat = varFilter(limma_res$voomObj$E, var.func=IQR, var.cutoff=0.95)

# transpose the matrix, so that it has the same shape as the d_mat we used at the beginning
d_mat = t(d_mat)

#
print(dim(d_mat))
#Run now again the commands to train the elastic net model, and to evaluate it. Has the performance increased or decreased? Are there more or less variables selected?
res = cv.glmnet(
  x = x_train,
  y = y_train,
  alpha = 0.5,
  family = "binomial"
)
# Test/Make prediction on test dataset
y_pred = predict(res, newx=x_test, type="class", s="lambda.min")
confusion_matrix = table(y_pred, y_test)

# Evaluation statistics
print(confusion_matrix)

print(paste0("Sensitivity: ",sensitivity(confusion_matrix)))
print(paste0("Specificity: ",specificity(confusion_matrix)))
print(paste0("Precision: ",precision(confusion_matrix)))
#better gaunas precicion

#regenerate train sets nelabai suprantu nes tie patys skaičiai gaunas
# size before
print(dim(x_train))
print(dim(x_test))

x_train = d_mat[train_ids, ]
x_test  = d_mat[-train_ids, ]

# size after
print(dim(x_train))
print(dim(x_test))
```
# Survival
```{r}
# Load packages
library("TCGAbiolinks")
library("limma")
library("edgeR")
library("glmnet")
library("factoextra")
library("FactoMineR")
library("caret")
library("SummarizedExperiment")
library("gplots")
library("survival")
library("survminer")
library("RColorBrewer")
library("gProfileR")
library("genefilter")

# NB: make sure you set the working directory of RStudio correctly

tcga_data = readRDS(file = "tcga_data.RDS")
limma_res = readRDS(file = "limma_res.RDS")
```
```{r}
# extract clinical data
clinical = tcga_data@colData

dim(clinical)

# we are only interested in the "Primary solid Tumor" cases for survival
clin_df = clinical[clinical$definition == "Primary solid Tumor",
                    c("patient",
                      "vital_status",
                      "days_to_death",
                      "days_to_last_follow_up",
                      "site_of_resection_or_biopsy", #pakeičiau iš gender
                      "figo_stage")] #čia pakeičiau iš tumor stage
```
```{r}
# create a new boolean variable that has TRUE for dead patients
# and FALSE for live patients
clin_df$deceased = clin_df$vital_status == "Dead"

# create an "overall survival" variable that is equal to days_to_death
# for dead patients, and to days_to_last_follow_up for patients who
# are still alive
clin_df$overall_survival = ifelse(clin_df$deceased,
                                   clin_df$days_to_death,
                                   clin_df$days_to_last_follow_up)

# show first 10 samples
head(clin_df)
```
```{r}
Surv(clin_df$overall_survival, clin_df$deceased)

Surv(clin_df$overall_survival, clin_df$deceased) ~ clin_df$site_of_resection_or_biopsy
```
```{r}
# fit a survival model
fit = survfit(Surv(overall_survival, deceased) ~ site_of_resection_or_biopsy, data=clin_df)

print(fit)
```
```{r}
# we produce a Kaplan Meier plot
ggsurvplot(fit, data=clin_df, pval=T)
```

```{r}
ggsurvplot(fit, data=clin_df, pval=T, risk.table=T, risk.table.col="strata")
```
```{r}
# remove any of the letters "a", "b" or "c", but only if they are at the end
# of the name, eg "stage iiia" would become simply "stage iii"
clin_df$figo_stage = gsub("[ABC]$", "", clin_df$figo_stage)

# we remove those with stage "not reported", since they are unknown
clin_df[which(clin_df$figo_stage == "not reported"), "figo_stage"] = NA #man rodos nebuvo na

# finally, we also remove those with tumor stage 4, since they are too few #salinu stage 1
clin_df[which(clin_df$figo_stage == "Stage I"), "figo_stage"] = NA

table(clin_df$figo_stage)
```
```{r}
fit = survfit(Surv(overall_survival, deceased) ~ figo_stage, data=clin_df)

# we can extract the survival p-value and print it
pval = surv_pvalue(fit, data=clin_df)$pval
print(pval)

# we produce a Kaplan-Meier plot from the fitted model
ggsurvplot(fit, data=clin_df, pval=T, risk.table=T)
```
# Survival + gene expression
```{r}
# let's extract the table of differential expression we got earlier
expr_df = limma_res$topGenes

# print the first row, to see the gene name, the logFC value and the p-value
print(expr_df[2, ]) #renkuosi top 2 nes pirmo ner matricoj po to kazkodel

#pasitikrinu ar bus kur reik genas:
is.my.gene <- grepl("ENSG00000117215.15", colnames(d_mat))
table(is.my.gene)
###select 1 top gene

# get the ensembl gene id of the first row
gene_id = expr_df[2, "gene_id"]

# also get the common gene name of the first row
gene_name = expr_df[2, "gene_name"]
```
```{r}
# visualize the gene expression distribution on the diseased samples (in black)
# versus the healthy samples (in red)
expr_diseased = d_mat[rownames(clin_df), gene_id]
expr_healthy = d_mat[setdiff(rownames(d_mat), rownames(clin_df)), gene_id]

boxplot(expr_diseased, expr_healthy,
        names=c("Diseased", "Healthy"), main="Distribution of gene expression")
```
```{r}
# get the expression values for the selected gene
clin_df$gene_value = d_mat[rownames(clin_df), gene_id]

# find the median value of the gene and print it
median_value = median(clin_df$gene_value)
print(median_value)

# divide patients in two groups, up and down regulated.
# if the patient expression is greater or equal to them median we put it
# among the "up-regulated", otherwise among the "down-regulated"
clin_df$gene = ifelse(clin_df$gene_value >= median_value, "UP", "DOWN")

# we can fit a survival model, like we did in the previous section
fit = survfit(Surv(overall_survival, deceased) ~ gene, data=clin_df)

# we can extract the survival p-value and print it
pval = surv_pvalue(fit, data=clin_df)$pval
print(pval)

# and finally, we produce a Kaplan-Meier plot
ggsurvplot(fit, data=clin_df, pval=T, risk.table=T, title=paste(gene_name))
```

