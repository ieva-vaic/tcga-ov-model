---
title: "XENA_OV"
author: "Ieva"
date: "2023-08-29"
output: html_document
---
This is recreation of chen 2022 protocol 

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(UCSCXenaTools);
library(data.table);
library(R.utils);
library(dplyr);
#stage 2
library(limma);
library(edgeR)
#stage3
library(WGCNA)
#stage4
library(grex);
library(biomaRt);
library(topGO);
library(ggplot2)
#stage5
library(RegParallel);
library(survminer)
#last stage
library(dplyr);
library(DGCA)
```
Step 1.4 Generate an object tracking all data sets from Xena Data Hubs
UCSC Xena Data Hubs can be filtered by their XenaHostNames, XenaCohorts, and/or XenaDatasets
```{r}
data(XenaData);
write.csv(XenaData, "00_tblXenaHubInfo.csv")
```
[Step 5-a] Target = RSEM expected counts provided by the UCSC Toil Recompute Compendium
The TcgaTargetGtex_gene_expected_count dataset for the TCGA TARGET GTEx cohort
from host toilHub.
```{r}
GeneExpectedCnt_toil = XenaGenerate(subset = XenaHostNames == "toilHub") %>%
XenaFilter(filterCohorts = "TCGA TARGET GTEx") %>%
XenaFilter(filterDatasets = "TcgaTargetGtex_gene_expected_count");
XenaQuery(GeneExpectedCnt_toil) %>%
XenaDownload(destdir = "./") #download once! slow!
```
[Step 5-b] Target = TCGA Clinical data.
```{r}
paraCohort = "TCGA Ovarian Cancer"; #Selecting the OVARIAN Cancer cohort.
paraDatasets = "TCGA.OV.sampleMap/OV_clinicalMatrix"; #Selecting the OVARIAN Cancer clinical matrix.
Clin_TCGA = XenaGenerate(subset = XenaHostNames == "tcgaHub") %>%
XenaFilter(filterCohorts = paraCohort) %>%
XenaFilter(filterDatasets = paraDatasets);
XenaQuery(Clin_TCGA) %>%
XenaDownload(destdir = "./") #surprisingly fast download
```
[Step 5-c] Target = TCGA Survival data.
```{r}
Surv_TCGA = XenaGenerate(subset = XenaHostNames == "toilHub") %>%
XenaFilter(filterCohorts = "TCGA TARGET GTEx") %>%
XenaFilter(filterDatasets = "TCGA_survival_data");
XenaQuery(Surv_TCGA) %>%
XenaDownload(destdir = "./") #surprisingly fast download
```
[Step 5-d] Target = GTEx Phenotype data.
```{r}
Pheno_GTEx = XenaGenerate(subset = XenaHostNames == "toilHub") %>%
XenaFilter(filterCohorts = "TCGA TARGET GTEx") %>%
XenaFilter(filterDatasets = "TcgaTargetGTEX_phenotype");
XenaQuery(Pheno_GTEx) %>%
XenaDownload(destdir = "./") #surprisingly fast download
```

Subset the gene expression matrix to include only observations of desired tissue type(s).
[Step 6-a] Retrieve IDs for GTEx normal samples of desired tissue type(s).
```{r}
filterGTEx01 = fread("TcgaTargetGTEX_phenotype.txt.gz");
names(filterGTEx01) = gsub("\\_", "", names(filterGTEx01));
paraStudy = "GTEX"; #Setting "GTEx" as the study of interest.
paraPrimarySiteGTEx = "Ovary"; #Setting "Ovary" as the primary site of interest.
paraPrimaryTissueGTEx = "^Ovary"; #Setting "Ovary" as the primary tissue of interest.
filterGTEx02 = subset(filterGTEx01,
study == paraStudy &
primarysite == paraPrimarySiteGTEx &
grepl(paraPrimaryTissueGTEx, filterGTEx01$`primary disease or tissue`))
```
[Step 6-b] Retrieve IDs for TCGA primary tumor samples of desired histological type(s).

..The Cancer Genome Atlas (TCGA) program provides gene expression data from
primary tumors. For differential gene expression analysis, we selected TCGA colon cancer
primary tumor samples by setting the filters: 
paraDatasets = TCGA.OV.sampleMap/OV_clinicalMatrix 
and
paraHistologicalType = Serous Cystadenocarcinoma
```{r}
filterTCGA01 = fread(paraDatasets);
names(filterTCGA01) = gsub("\\_", "", names(filterTCGA01));
paraSampleType = "Primary Tumor"; #Setting "Primary Tumor" as the sample type of interest.
paraPrimarySiteTCGA = "Ovary"; #Setting "Ovary" as the primary site of interest.
paraHistologicalType = "Serous Cystadenocarcinoma"; #Setting "Serous Cystadenocarcinoma" as the histological type of interest.
filterTCGA02 = subset(filterTCGA01,
sampletype == paraSampleType &
primarysite == paraPrimarySiteTCGA &
grepl(paraHistologicalType, filterTCGA01$histologicaltype))
```

[Step 6-c] Merge GTEx and TCGA sample lists. Then pull expression profiles from .gz file by IDs on merged sample list

The TcgaTargetGtex_gene_expected_count dataset from the toilHub data hub combines
RNA-Seq data from TCGA and GTEx by uniformly realigning reads to the hg38 genome
and re-calling expressions using RSEM and Kallisto methods (Vivian et al., 2017). 
The RSEM algorithm uses the expectation-maximization technique, it can operate with and without a reference, and reports transcripts per million mapped reads (TPM).
Kallisto is based on the novel idea of pseudoalignment for rapidly determining the compatibility of reads with targets, without the need for alignment.
```{r}
filterExpr = c(filterGTEx02$sample, filterTCGA02$sampleID, "sample");
ExprSubsetBySamp = fread("TcgaTargetGtex_gene_expected_count.gz",
select = filterExpr)
```
IEVA comment. this fread did not run on home windows as it requires a lot of memory
the work linux produces error but I think I's fine, as the resulting ExprSubsetBySamp has
14579   508 cases -> seems more like 507 as the samples is gene name
expectinau 88 gtex + 419 tcga cases 

Subset the gene expression matrix to include only protein-coding genes. This can be achieved by
utilizing the zz_gene.protein.coding.csv saved during step 1

```{r}
probemap = fread("zz_gencode.v23.annotation.csv", select = c(1, 2));
exprALL = merge(probemap, ExprSubsetBySamp, by.x = "id", by.y = "sample");
genesPC = fread("zz_gene.protein.coding.csv"); #warning meta, 
exprPC = subset(exprALL, gene %in% genesPC$Gene_Symbol);
#Remove duplicate gene symbols.
exprFinal = exprPC[!(duplicated(exprPC$gene) |
duplicated(exprPC$gene, fromLast = TRUE)), ]
```
[Main Text: Step 8] Save the expression profile data frame for downstream analyses.
```{r}
write.csv(exprFinal, "00_ExpectedCnt.csv")
```
The COAD_clinicalMatrix dataset contains 133 administrative and phenotypic annotations. Keep only what you want.
[Main Text: Step 9] Prepare clinical data to include only desired variables.
```{r}
#Print out a list of all available variables for the Colon Cancer cohort of TCGA.
names(filterTCGA02)
```
Fisrt tutorialui nekeisiu, paliksiu limphatic invasion. po to pakeisiu i stage
```{r}
#Keep variable "Lymphatic Invasion".
varClinKeep = c("sampleID", "lymphaticinvasion", "clinicalstage", "vitalstatus", "ageatinitialpathologicdiagnosis", "neoplasmhistologicgrade" ); #cia yra ziauriai geruuu
clinDF01 = as.data.frame(do.call(cbind, filterTCGA02));
clinFinal = clinDF01[varClinKeep];
#Identify observations/samples with no values assigned to the kept variables.
colSums(clinFinal == "");
```
```{r}
colSums(is.na(clinFinal)); #rodo kiek nas
#Replace "no values" with "NA"
NA -> clinFinal[clinFinal == ""];
colSums(is.na(clinFinal));

```
```{r}
#For the variable "Lymphatic Invasion", check count of YES/NO.
table(clinFinal$lymphaticinvasion);
#Re-code the variable "Lymphatic Invasion" from YES/NO to 1/0.
clinFinal$lymphaticinvasion = if_else(clinFinal$lymphaticinvasion == "YES",
1, 0, missing = NULL);
#Verify that the count of 1/0 mirrors previous count of YES/NO.
table(clinFinal$lymphaticinvasion);
###
#For the variable "stage", check counts
table(clinFinal$clinicalstage, useNA = "a");
#Re-code the variable "Stage" from Stage IA.. to.. atsiranda nas prie STAGE I and then to -2 -1 0 +1.
clinFinal$clinicalstage2= gsub("[ABC]$", "", clinFinal$clinicalstage)
table(clinFinal$clinicalstage2, useNA = "a") 
clinFinal$clinicalstage_num <- clinFinal$clinicalstage2
clinFinal$clinicalstage_num <- recode(clinFinal$clinicalstage_num, "Stage I" = -2, "Stage II" = -1, "Stage III" = 0, "Stage IV" = 1)
table(clinFinal$clinicalstage_num, useNA = "a") 
```

[Main Text: Step 10] Save the clinical data data frame for downstream analyses.
```{r}
write.csv(clinFinal, "00_ClinTraits.csv")
```

## Differential gene expression analysis with limma-voom Steps 11 - 25
[Main Text: Step 12] Back transformation of log-transformed expected count.
The TcgaTargetGtex_gene_expected_count dataset for the TCGA TARGET GTEx cohort
from host toilHub was previously log 2 (x+1) transformed. As such, it is necessary to back-trans-
form the gene expression matrix that was saved to the working directory during step 8 into
RSEM gene-level expected count before passing the dataset to limma
```{r}
exprFinal = read.csv("00_ExpectedCnt.csv");
exprBT = exprFinal[, -c(1:3)];
rownames(exprBT) = exprFinal$gene;
exprBT = round(((2^exprBT)-1), 0);
write.csv(exprBT, "01_ExpectedCntBT.csv")
```
Convert the back-transformed gene expression matrix into a DGEList-object using the DGEList
function.
In limma-voom, all samples are assumed to have a similar range and distribution of log-
CPM values (Law et al., 2016). Samples that have significantly different range and/or distribu-
tion of log-CPM values should be removed prior to the generation of the DGEList-object

Methods S11: R Markdown Code Script for Troubleshooting
Problem 3 - Ovarian Cancer Related to Problem 3 Step 13
[Main Text: Step 13] Convert count data to DGEList object
```{r}
#Run limma up uptil the generation of the density plot to check to see if there are any sample outliers
expLIMMA = exprBT
#The DGEList contains x$samples , within which we have x$samples$lib.size and x$samples$norm.factors . Upon execution of the DGEList function, the normalization factor is temporarily set to 1, and the library size is calculated for each sample
x = DGEList(expLIMMA)
```
IEVA: sitas limma dge_list useful yra
```{r}
saveRDS(x, "x_dge_list.RDS")
```


[Main Text: Step 14] Group samples by condition (i.e., TCGA tumor or GTEx normal).
```{r}
snames = colnames(x);
group = substr(snames, 1, 4); #Sets up level information for samples.
x$samples$group = group #Assigns samples to appropriate group.
```
[Main Text: Step 15] Compute counts per million.
```{r}
cpm = cpm(x);
lcpm = cpm(x, log = TRUE);
L = mean(x$samples$lib.size) * 1e-6;
L; #Displays average library size in millions. #pavyzdy buvo 52.70373
M = median(x$samples$lib.size) * 1e-6;
M; #Displays median library size in millions. #pavyzdy buvo 51.93371
table(x$samples$group) #Returns number of samples per group. #all good pvz 88 ir 419
```
[Main Text: Step 16] Remove genes that are lowly expressed
```{r}
keep.exprs = filterByExpr(x, group = group);
x = x[keep.exprs, , keep.lib.sizes = FALSE];
dim(x) #Returns number of genes and samples retained. pvz buvo ## [1] 16243 507
```
Generate density plot of log-CPM values for QC.
```{r}
lcpm.cutoff = log2(10/M + 2/L);
nsamples = ncol(x);
par(mfrow=c(1, 2));
plot(density(lcpm[, 1]), lwd = 2, ylim = c(0, 0.26), las = 2, main = "", xlab = "");
title(main = "A. Expected Count", xlab = "Log-CPM");
abline(v = lcpm.cutoff, lty = 3);
for (i in 2:nsamples){
den = density(lcpm[, i])
lines(den$x, den$y, lwd = 2)
}
lcpm = cpm(x, log = TRUE);
plot(density(lcpm[, 1]), lwd = 2, ylim = c(0, 0.26), las = 2, main = "", xlab = "");
title(main = "B. Filtered Expected Count", xlab = "Log-CPM");
abline(v = lcpm.cutoff, lty = 3);
for (i in 2:nsamples){
den = density(lcpm[, i])
lines(den$x, den$y, lwd = 2)
}
```
Density plot indicate that there are observations (samples) that are distant from other observations. The lcpm data matrix and the
lcpm.cutoff value will be used to detect outliers.

```{r}
t.lcpm = as.data.frame(t(lcpm));
t.lcpm$failed.Threshold = rowSums(t.lcpm < lcpm.cutoff);
nGenes = ncol(t.lcpm);
t.lcpm$density = t.lcpm$failed.Threshold / nGenes;
par(mfrow=c(1, 2));
byHist = hist(t.lcpm$density,
main = "Histogram of Density",
xlab = "Density",
breaks = sqrt(nrow(t.lcpm)));
```
Histogram shows that the outliers have density values > 0.8 for lcpm values < lcpm.cutoff. Observations (samples) that satisfy these
conditions will be called out.
```{r}
anomaly = rownames(subset(t.lcpm, density > 0.8));
anomaly #Prints list of sample IDs. #pvz buvo  [1] "TCGA.25.1870.01, tas pats
```
The sample IDs listed above should be removed from the back-transformed gene expression matrix before converting the matrix into a
DGEList-object for the actual run of limma-voom.

```{r}
expLIMMA = exprBT[, -which(names(exprBT) %in%
c("TCGA.25.1870.01"))]
```
Ieva: repeat after removal of the one person
maintext:
14. Group samples by condition (i.e., TCGA tumor or GTEx normal).
15. Convert expected counts to counts per million (CPM) and log 2 -counts per million using the func-
tion cpm.
16. Remove genes that are lowly expressed using the function filterByExpr.
17. Perform normalization on gene expression using the function calcNormFactors.
18. Generate a design matrix using the function model.matrix.
19. Set up contrast for comparison using the function makeContrasts.
20. Transform gene expression data for linear modeling using the function voom.
21. Perform linear modeling using the function lmFit, then the function contrasts.fit.
22. Compute empirical Bayes statistics for differential expression using the function eBayes.
23. Inspect the number of significantly up- and down-regulated genes.
24. Save the list of DEGs for subsequent analyses.
25. Save the voom transformed gene expression matrix for subsequent analyses.
```{r}
x = DGEList(expLIMMA)

snames = colnames(x);
group = substr(snames, 1, 4); #Sets up level information for samples.
x$samples$group = group #Assigns samples to appropriate group.

cpm = cpm(x);
lcpm = cpm(x, log = TRUE);
L = mean(x$samples$lib.size) * 1e-6;
L; #Displays average library size in millions.
M = median(x$samples$lib.size) * 1e-6;
M; #Displays median library size in millions.
table(x$samples$group)
keep.exprs = filterByExpr(x, group = group);
x = x[keep.exprs, , keep.lib.sizes = FALSE];
dim(x) #Returns number of genes and samples retained.

#plot
lcpm.cutoff = log2(10/M + 2/L);
nsamples = ncol(x);
par(mfrow=c(1, 2));
plot(density(lcpm[, 1]), lwd = 2, ylim = c(0, 0.26), las = 2, main = "", xlab = "");
title(main = "A. Expected Count", xlab = "Log-CPM");
abline(v = lcpm.cutoff, lty = 3);
for (i in 2:nsamples){
den = density(lcpm[, i])
lines(den$x, den$y, lwd = 2)
}
lcpm = cpm(x, log = TRUE);
plot(density(lcpm[, 1]), lwd = 2, ylim = c(0, 0.26), las = 2, main = "", xlab = "");
title(main = "B. Filtered Expected Count", xlab = "Log-CPM");
abline(v = lcpm.cutoff, lty = 3);
for (i in 2:nsamples){
den = density(lcpm[, i])
lines(den$x, den$y, lwd = 2)
}
```
[Main Text: Step 17] Compute scaling factors to convert observed library sizes into effective library sizes.
the effective library sizes for use in downstream analyses are determined by lib.size and norm.factors , where lib.size contains
the original library sizes and norm.factors is the output from calcNormFactor.
```{r}
x = calcNormFactors(x, method = "upperquartile")
head(x$samples$norm.factors) #Prints out example normalization factors.
```
[Main Text: Step 18] Generate design matrix.
```{r}
design = model.matrix(~0 + group) #group I think is gtex or tcga
```
[Main Text: Step 19] Set up contrast for comparison.
```{r}
colnames(design) = gsub("group", "", colnames(design));
contr.matrix = makeContrasts(TCGAvsGTEX = TCGA - GTEX,
levels = colnames(design))
```
[Main Text: Step 20] Transform RNA-Seq data for linear modeling.]
IEVA: cia sunormalizuoja, o toliau modeli taiko
```{r}
v = voom(x, design, plot = TRUE)
```
Ieva: save v 
```{r}
saveRDS(v, "v.RDS")
```

[Main Text: Step 21] Fit a linear model using weighted least squares for each gene.
```{r}
vfit = lmFit(v, design)
vfit = contrasts.fit(vfit, contrasts = contr.matrix) #Returns the logFC between groups (TCGA vs. GTEx) via contrasts of the fitted linear models.
```
[Main Text: Step 22] Perform empirical Bayes smoothing of standard errors.
```{r}
efit = eBayes(vfit);
plotSA(efit, main="Final model: Mean-variance trend")
```
[Main Text: Step 23] Examine the number of DEGs.
```{r}
summary(decideTests(efit))
```
The number of DEGs is large. As such, treat is used to compute empirical Bayes moderated-t p-values relative to a minimum fold-change threshold of 0.58.
```{r}
tfit = treat(vfit, lfc = 0.58);
summary(decideTests(tfit)) #Examines the number of DEGs with the added condition of minimum log-FC of 0.58.
```
[Main Text: Step 24] Write out the DEG data frame for downstream analyses
```{r}
DEGsTreat = topTreat(tfit, n = Inf);
write.csv(DEGsTreat, "01_DEGsTreat.csv")
```
[Main Text: Step 25] Write out voom normalized expression profile for downstream WGCNA.
```{r}
voomExpr = v$E;
write.csv(voomExpr, "01_voomExpr.csv")
```
## Identification of gene set(s) highly correlated to specific traits of human cancer with WGCNA

[Main Text: Step 27] For WGCNA, use only TCGA expression data.
```{r}
options(stringsAsFactors = FALSE);
dataExpr0 = read.csv("01_voomExpr.csv"); #when you read csv, the rownames are lost
rownames(dataExpr0) <- dataExpr0$X
head(dataExpr0[1:6]); #contains gtex
dataExpr1 = dataExpr0 %>% select(starts_with("TCGA"));
head(dataExpr1[1:6]); #only tcga left
```
[Main Text: Step 28] Exclude genes with overall low expression
```{r}
#Add a new variable "Count" that counts the number of samples that have normalized expression value <0 for gene x

dataExpr1$Count = rowSums(dataExpr1 < 0);
table(dataExpr1$Count);

#Keep genes that have "Count" = 0 (i.e., Keep genes that have non-negative normalized expression value across ALL samples).
dataExpr2 = dataExpr1 %>% filter(Count == 0);
#Remove the "Count" variable from the gene expression matrix.
dataExpr2$Count = NULL
dataExpr3 = as.data.frame(t(dataExpr2))

gsg = goodSamplesGenes(dataExpr3, verbose = 3);
gsg$allOK;
{
if(sum(!gsg$goodGenes)>0)
printFlush(paste("Removing genes:", paste(names(dataExpr3)[!gsg$goodGenes], collapse = ", ")));
if(sum(!gsg$goodSamples)>0)
printFlush(paste("Removing samples:", paste(rownames(dataExpr3)[!gsg$goodSamples], collapse = ", ")));
dataExpr3 = dataExpr3[gsg$goodSamples, gsg$goodGenes]
}
```
[Main Text: Step 29] Cluster samples base on their Euclidean distance to see if there are any sample outliers.
```{r}
sampleTree = hclust(dist(dataExpr3), method = "average"); 

plot(sampleTree,
main = "Sample Clustering to Detect Sample Outliers",
sub = "",
xlab = "",
cex = 0.6);
abline(h = 100, col = "red"); #Cut tree at height 100.
```
Histogram suggests that the outliers have height > 100. We can draw a line at 100 on the clustering dendrogram to assess whether or not the chosen cut height of 100 is reasonable.
```{r}
par(mfrow=c(1, 2));
byHist = hist(sampleTree$height,
main = "Histogram of Height",
xlab = "Height")
```
```{r}
clust = cutreeStatic(sampleTree,
cutHeight = 100,
minSize = 10);
table(clust) #If cutting tree at height 100, 13 samples will be deemed as outliers.

keepSamples = (clust == 1);
dataExpr4 = dataExpr3[keepSamples, ];
nGenes = ncol(dataExpr4);
nGenes; #Displays number of genes retained after removal of lowly-expressed genes.

nSamples = nrow(dataExpr4);
nSamples #Displays number of samples retained after removal of sample outliers.

#Re-cluster kept samples to inspect distribution.
sampleTree2 = hclust(dist(dataExpr4), method = "average");
plot(sampleTree2,
main = "Sample Clustering after Removal of Sample Outliers",
sub = "",
xlab = "",
cex = 0.6);

dataExpr = dataExpr4
```
[Main Text: Step 30] Prepare clinical trait data for WGCNA.
```{r}
dataTraitALL = read.csv("00_ClinTraits.csv");
head(dataTraitALL);

dataTraitALL$sampleID = gsub("-", ".", dataTraitALL$sampleID);
head(dataTraitALL)
#Form a trait data frame analogous to the expression data frame.
exprRows = rownames(dataExpr);
traitRows = match(exprRows, dataTraitALL$sampleID);
dataTrait = dataTraitALL[traitRows, -1];
head(dataTrait);

rownames(dataTrait) = dataTrait$sampleID;
head(dataTrait);

dataTrait = select(dataTrait, -sampleID);
head(dataTrait)
```


Visualize how the trait data relates to sample clustering.
```{r}
sampleTree3 = hclust(dist(dataExpr), method = "average");
traitColors = numbers2colors(dataTrait$clinicalstage_num, signed = FALSE)
```
In the plot below, trait was converted to a color representation of absolute data value. Where white means low, red means high, and gray means missing entry
```{r}
plotDendroAndColors(sampleTree3,
traitColors,
groupLabels = "stages", #name the group
main = "Sample Dendrogram in Relation to Traits",
autoColorHeight = FALSE,
colorHeight = 0.1)
```
[Save point] Backup TCGA gene expression and traits .Rdata.
```{r}
save(dataExpr, dataTrait, file = "02_WGCNAdataInput.RData")
```
[Main Text: Step 31] Analyze scale free topology for a set of soft-thresholding power to select appropriate soft thresholding power for network construction.
```{r}
powers = c(c(1:10), seq(from = 12, to = 20, by = 2));
sft = pickSoftThreshold(dataExpr,
powerVector = powers,
networkType = "signed",
verbose = 5,
blockSize = 20000)
```
[Main Text: Step 32] Plot results returned by the function pickSoftThreshold .
```{r}
plot(sft$fitIndices[, 1], -sign(sft$fitIndices[, 3])*sft$fitIndices[, 2],
xlab = "Soft Threshold (power)",
ylab = "Scale Free Topology Model Fit, signed R^2",
type = "n",
main = paste("Scale Independence"));
text(sft$fitIndices[, 1], -sign(sft$fitIndices[, 3])*sft$fitIndices[, 2],
labels = powers,
col = "red");
abline(h = 0.90,
col = "red")
```
```{r}
plot(sft$fitIndices[, 1], sft$fitIndices[, 5],
xlab = "Soft Threshold (power)",
ylab = "Mean Connectivity",
type = "n",
main = paste("Mean Connectivity"));
text(sft$fitIndices[, 1], sft$fitIndices[, 5],
labels = powers,
col = "red")
```
```{r}
k = softConnectivity(dataExpr,
type = "signed",
power = 10, #choose
blockSize = 20000,
verbose = 2)
```

```{r}
sum(is.na(k))
par(mfrow=c(1, 2));
byHist = hist(k)

```
Visualize scale-free topology when the selected soft-thresholding power, beta = 10.
```{r}
scaleFreePlot(k, main = "Scale Free Plot (Pearson), sft=10\n")
```
[Main Text: Step 33] Calculate network adjacency from the gene expression matrix.
```{r}
softPower = 10;
adjacency = adjacency(dataExpr,
power = softPower,
type = "signed")
```
[Main Text: Step 34] Calculate the topological overlap matrix (TOM) from the adjacency matrix.
```{r}
TOM = TOMsimilarity(adjacency,
TOMType = "signed",
verbose = 5)
```
TOM can then be used to generate the dissimilarity matrix that minimizes the effects of noise and spurious associations for subsequent hierarchical clustering.
```{r}
dissTOM = 1 - TOM
```
[Main Text: Step 35] Hierarchical clustering and module assignment.
```{r}
geneTree = hclust(as.dist(dissTOM),
method = "average");
plot(geneTree,
xlab = "",
sub = "",
main = "Gene Clustering",
labels = FALSE,
hang = 0.04);
```
```{r}
minModuleSize = 100;
dynamicMods = cutreeDynamic(dendro = geneTree,
distM = dissTOM,
method = "hybrid",
deepSplit = 4,
pamStage = TRUE,
pamRespectsDendro = FALSE,
minClusterSize = minModuleSize,
verbose = 4)
```
```{r}
table(dynamicMods) #5 models
```
```{r}
dynamicColors = labels2colors(dynamicMods);
plotDendroAndColors(geneTree,
dynamicColors,
"Dynamic Tree Cut",
dendroLabels = FALSE, hang = 0.03,
addGuide = TRUE, guideHang = 0.05,
main = "Gene Dendrogram and Module Colors")
```
Main Text: Step 36] Calculate module eigengenes (MEs, i.e., first principal component).
```{r}
MEList = moduleEigengenes(dataExpr,
colors = dynamicColors)

MEs = MEList$eigengenes #extract matrix matrix containing the sample eigen value for each module

#Save point] Backup MEs and module assignments .Rdata.
save(MEs, dynamicMods, dynamicColors, geneTree,
file = "02_WGCNAmodAssigned.RData")
```

[Main Text: Step 37] Relate sample’s eigen values to sample’s clinical trait.
```{r}
moduleTraitCor = cor(MEs, dataTrait, use = "p");
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples);
textMatrix = paste(signif(moduleTraitCor, 2), " (",
signif(moduleTraitPvalue, 1), ")", sep = "");
dim(textMatrix) = dim(moduleTraitCor);
par(mar = c(6, 8.5, 3, 3));
labeledHeatmap(Matrix = moduleTraitCor,
xLabels = names(dataTrait),
yLabels = names(MEs),
ySymbols = names(MEs),
colorLabels = FALSE,
colors = blueWhiteRed(50),
textMatrix = textMatrix,
setStdMargins = FALSE,
cex.text = .65,
zlim = c(-1,1),
main = paste("Module-Trait Relationships")) #I need to make all clinical traits binomial
```
[Main Text: Step 38] Relate gene expression levels to clinical trait(s). i.e., Gene Significance.
```{r}
geneTraitSignificance = as.data.frame(cor(dataExpr, dataTrait$clinicalstage_num, use = "p"));
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples));
names(geneTraitSignificance) = "clinicalstage_num";
names(GSPvalue) = "p.clinicalstage_num"
```
[Main Text: Step 39] Relate gene expression levels to modules. i.e., Module Membership.
```{r}
modNames = substring(names(MEs), 3);
geneModuleMembership = as.data.frame(cor(dataExpr, MEs, use = "p"));
MMPvalue = as.data.frame(corPvalueStudent(as.matrix(geneModuleMembership), nSamples));
names(geneModuleMembership) = paste("MM", modNames, sep="");
names(MMPvalue) = paste("p.MM", modNames, sep="")
```
[Main Text: Step 40] Examine the gene significance (GS) vs. module membership (MM) relationship.
```{r}
module = "turquoise";
column = match(module, modNames);
moduleGenes = dynamicColors == module;
verboseScatterplot(geneModuleMembership[moduleGenes, column],
geneTraitSignificance[moduleGenes, 1],
xlab = paste("Module Membership in", module, "Module"),
ylab = "Gene Significance for stage",
main = paste ("Module Membership vs.Gene Significance\n"),
cex.main = 1,
cex.lab = 1,
cex.axis = 1,
col = module)
```
[Main Text: Step 41] Annotate results from WGCNA.
```{r}
annot = read.csv(file = "zz_gencode.v23.annotation.csv", sep="\t" )
dim(annot);
head(annot)
```
```{r}
probes = names(dataExpr);
probes2annot = match(probes, annot$gene);
sum(is.na(probes2annot)) #Checks for number of probes without annotation. Should be zero. #ieva; it is 0 now
```
```{r}
ExportPrep = data.frame(geneSymbol = probes,
geneSymbolCheck = annot$gene[probes2annot],
ENSG = annot$id[probes2annot],
moduleColor = dynamicColors,
geneTraitSignificance,
GSPvalue);
modOrder = order(-(cor(MEs, dataTrait$clinicalstage_num, use = "p")));
for (mod in 1:ncol(geneModuleMembership))
{
oldNames = names(ExportPrep)
ExportPrep = data.frame(ExportPrep, geneModuleMembership[, modOrder[mod]],
MMPvalue[, modOrder[mod]]);
names(ExportPrep) = c(oldNames, paste("MM.", modNames[modOrder[mod]], sep=""),
paste("p.MM.", modNames[modOrder[mod]], sep=""))
}
geneOrder = order(ExportPrep$moduleColor, -abs(ExportPrep$clinicalstage_num));
ExportFinal = ExportPrep[geneOrder, ]
```
[Main Text: Step 42] Save annotated WGCNA results for downstream GO analysis.
```{r}
write.csv(ExportFinal, file = "02_GSandMM.csv")
```
# topGO
[Main Text: Step 44] Annotate results from WGCNA with Entrez IDs
```{r}
annot = fread("02_GSandMM.csv",
select = c("geneSymbol", "ENSG", "moduleColor"));
annot$ensembl = substr(annot$ENSG, 1, 15);
ensembl_id = annot$ensembl;
all_id = grex(ensembl_id);
annotComplete = merge(annot, all_id,
by.x = "ensembl",
by.y = "ensembl_id");
write.csv(annotComplete, "03_moduleGeneAnnotated.csv")
```
[Main Text: Step 45] For GO annotation, connect to the ENSEMBL_MART_ENSEMBL BioMart databasae to query GO IDs for the input entrezgene_id .
```{r}
genes_bg = annotComplete$entrez_id;
length(genes_bg) #2710
```
```{r}
tot_background = length(genes_bg);
db = useMart("ENSEMBL_MART_ENSEMBL",
dataset = "hsapiens_gene_ensembl",
host = "www.ensembl.org");
go_ids = getBM(attributes = c("go_id",
"entrezgene_id",
"namespace_1003"),
filters = "entrezgene_id",
values = genes_bg,
mart = db)
```
[Main Text: Step 46] Define (WGCNA) module of interest and set up named factors for genes of interest.
```{r}
modInt = as.factor(annotComplete$moduleColor);
annotSplit = split(annotComplete, modInt);
candidate_list = annotSplit$turquoise$entrez_id; #chooose color!
length(candidate_list) #turquoise 914
```
```{r}
tot_candidate = length(candidate_list);
keep = candidate_list %in% go_ids[, 2];
keep = which(keep == TRUE);
candidate_list = candidate_list[keep];
geneList = factor(as.integer(genes_bg %in% candidate_list));
names(geneList) = genes_bg
```
[Main Text: Step 47] Build topGO data object then run GO analysis
```{r}
gene2GO = unstack(go_ids[, c(1, 2)]);
GOdata = new("topGOdata",
ontology = c("BP"),
allGenes = geneList,
annot = annFUN.gene2GO,
gene2GO = gene2GO);
allGO = usedGO(GOdata)
```
[Main Text: Step 48] Test significance of enriched GO terms
```{r}
sigTest = runTest(GOdata,
algorithm = "elim",
statistic = "fisher")
```
[Main Text: Step 49] Generate a summary table of topGO results.
```{r}
all_res = GenTable(GOdata,
weightFisher = sigTest,
orderBy = "weightFisher",
topNodes = length(allGO))
```
[Main Text: Step 50] Calculate odds ratios
```{r}
all_res$OR = log2((all_res$Significant/tot_candidate) /(all_res$Annotated/tot_background));
write.csv(all_res, "03_moduleGOAnnotated.csv")
```
Main Text: Step 51] Generate a summary figure of topGO results.
For this example, threshold was set at weightFisher < 0.05 and annotated.backgound was set at Annotated >= 30 . As well, only the top 10 most significant GO terms were selected for presentation.
```{r}
#This sets the threshold p < 0.05 and #.annotated.background.genes >= 30.
GO_bar = all_res %>%
filter(weightFisher < 0.05) %>%
filter(Annotated >= 30);

GO_bar = GO_bar %>%
dplyr::select(Term, weightFisher, OR);

sapply(GO_bar, class)

GO_bar = transform(GO_bar, weightFisher = as.numeric(weightFisher));
sapply(GO_bar, class)
```

```{r}
#This selects the top 10 most significant (i.e., order by ascending p-values) GO terms for presentation.
GO_bar = GO_bar %>%
arrange(weightFisher) %>%
dplyr::slice(1:10)

CapStr = function(y) {
c = strsplit(y, " ")[[1]]
paste(toupper(substring(c, 1, 1)), substring(c, 2),
sep = "", collapse = " ")
}

GO_bar$Term = sapply(GO_bar$Term, CapStr);

p = ggplot(GO_bar,
aes(x = reorder(Term, OR), y = OR, fill = weightFisher)) +
geom_bar(stat = "identity", width = 0.9, color = "black") +
coord_flip() +
scale_fill_gradient(low="#feff2b",high="#fe0100") +
ylim(0, 3) +
labs(title = ~underline("Enriched GO Biological Processes"),
x = NULL,
y = "Odds Ratio",
fill = "p.value") +
theme_bw() +
theme(plot.title.position = "plot") +
theme(plot.title = element_text(size = 12)) +
theme(axis.title.x = element_text(size = 10, face = "bold"),
axis.title.y = element_text(size = 10, face = "bold")) +
theme(axis.text.x = element_text(size = 10, face = "bold"),
axis.text.y = element_text(size = 10, face = "bold")) +
theme(legend.position = "right");
p
```
# Survival
[Main Text: Step 53] Subset the voom normalized expression data to include only TCGA sample IDs and only genes within the module of interest.

ieva comment: the fact that they take this expression data makes me think I extracted the wrong normalization in glm
```{r}
dataExpr = read.csv("01_voomExpr.csv"); #again problem with imports
rownames(dataExpr) = dataExpr$X;
dataExpr = dataExpr %>% dplyr::select(starts_with("TCGA"));
head(dataExpr[1:4]) #3943 genes, 418 names
```
```{r}
genes_toKeep = read.csv("02_GSandMM.csv");
head(genes_toKeep[1:5])

genes_toKeep_list = genes_toKeep %>% filter(moduleColor == "turquoise");
genes_toKeep_list = genes_toKeep_list$geneSymbol;
dataExpr = dataExpr[genes_toKeep_list, ];
head(dataExpr[1:4])
```
[Main Text: Step 54] Transform expression data to Z-score.
Also, set Z-score cut-offs for high and low expression. Z-score of (+/-)0.674 translates to 25/75 percentile
```{r}
dataExpr = as.data.frame(t(dataExpr));
dataExpr = as.data.frame(scale(dataExpr));
head(dataExpr[1:4])

highExpr = 0.674;
lowExpr = -0.674;
dataExpr = as.data.frame(ifelse(dataExpr <= lowExpr, 1,
ifelse(dataExpr >= highExpr, 2, NA)));
dataExpr[] = lapply(dataExpr, factor);
dataExpr$SampleID = rownames(dataExpr)
```
[Main Text: Step 55] Create an object that contains both survival and Z-score data.
```{r}
dataSurv = as.data.frame(fread("TCGA_survival_data"));
dataSurv$sample = gsub("-", ".", dataSurv$sample);
head(dataSurv)

dataJoined = merge(dataSurv, dataExpr, by.x = "sample", by.y = "SampleID")
```
Generate a histogram that summarize the range and distribution of available survival data.
```{r}
temp4Hist = (dataJoined$OS.time)/365;
hist(temp4Hist,
breaks = seq(from = 0, to = 16, by = 1), #up to 16 from 15
xaxt='n',
xlab = "Years",
main = "Histogram of OS.time")

axis(side = 1,
at = seq(0, 16, 1),
labels = seq(0, 16, 1))
```
Histogram tells us that data is available for examining three-, five-, and/or 10-year overall survival probability. Subset OS.time for examination of 10-year overall survival probability.
```{r}
dataJoined = subset(dataJoined, OS.time <= 3650)
```
[Main Text: Step 56] Run RegParallel to test each gene independently via Cox regression.
```{r}
data = dataJoined
res = RegParallel(data = dataJoined,
formula = 'Surv(OS.time, OS) ~ [*]',
FUN = function(formula, data) coxph(formula = formula,
data = data,
ties = 'breslow',
singular.ok = TRUE),
FUNtype = 'coxph',
variables = colnames(dataJoined)[10:ncol(dataJoined)], #isrenka genus tik
blocksize = 151,
cores = 2,
nestedParallel = FALSE,
conflevel = 95);

res = res[!is.na(res$P), ];
res = res[order(res$LogRank, decreasing = FALSE)];
head(res)
```
failed, can`t continue

# Differential (co-expression) correlation analysis with DGCA
```{r}
dataExpr = read.csv("01_voomExpr.csv");
head(dataExpr[1:6]);
rownames(dataExpr) = dataExpr$X;
dataExpr = dataExpr[, -1];
head(dataExpr[1:6]);

#create datamatrix with gtex, tcga as bi-variables
dataSample = names(dataExpr);
group = substr(dataSample, 1, 4);
dataGTEx = as.numeric(ifelse(group == "GTEX", 1, 0));
dataTCGA = as.numeric(ifelse(group == "TCGA", 1, 0));
dataMatrix = data.frame(dataGTEx, dataTCGA);
dataMatrix = as.matrix(dataMatrix)
nrow(dataExpr) #3943
```
Filter the expression matrix by first removing genes with low median expression levels (central tendency). Then by the ratio of variance to mean (dispersion index).
```{r}
dataExpr = filterGenes(dataExpr,
filterTypes = "central",
keepRows = NULL,
filterCentralType = "median",
filterCentralPercentile = 0.25,
allGroups = FALSE,
design = NULL);
nrow(dataExpr) #2957

dataExpr = filterGenes(dataExpr,
filterTypes = "dispersion",
keepRows = NULL,
filterDispersionType = "dispersion_index",
filterDispersionPercentile = 0.25,
allGroups = FALSE,
design = NULL);
nrow(dataExpr) #2217
```
Compute the differential correlation (Pearson) of DAPK3 vs. All.
Perform differential correlation analysis on the hub gene between normal and primary tumor
using the function ddcorAll
Ieva; it is unclear to me how to find the hub gene, maybe choose a gene from earlier
```{r}
ddcor_DAPK3_PS = ddcorAll(inputMat = dataExpr,
design = dataMatrix,
inputMatB = NULL,
compare = c("dataGTEx", "dataTCGA"),
splitSet = "WAS",
impute = FALSE,
corrType = "pearson",
nPairs = "all",
sortBy = "zScoreDiff",
adjust = "perm",
nPerms = 1000,
classify = TRUE,
sigThresh = 0.05,
corSigThresh = 0.05,
heatmapPlot = FALSE,
color_palette = NULL,
verbose = FALSE,
plotFdr = FALSE,
corr_cutoff = 0.99,
signType = "none",
getDCorAvg = FALSE,
oneSidedPVal = FALSE)
```
random parinkau genus
```{r}
plotCors(inputMat = dataExpr, design = dataMatrix, compare = c("dataGTEx", "dataTCGA"), geneA = "WAS", geneB = "DOCK10")
```

