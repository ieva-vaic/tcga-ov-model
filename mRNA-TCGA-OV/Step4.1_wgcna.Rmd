---
title: "WGCNA mRNA TCGA-OV"
author: "Ieva"
date: "2023-08-16"
output:
  html_document: 
    toc: true
    theme: united
---
    
```{r setup, include=FALSE}
#namu windows
knitr::opts_chunk$set(cache = TRUE)
Sys.setenv(LANG = "en")
library(WGCNA)
library(DESeq2)
library(tidyverse)
library(CorLevelPlot)
library(gridExtra)
library(venn)
library(biomaRt)
library(org.Hs.eg.db)
library(clusterProfiler)
library(glmnet)
allowWGCNAThreads() 
```
```{r}
#I need as the assay gives: genes in rows
#using only traincounts
data <- readRDS("C:/Users/Ieva/Desktop/NVI GDL/R projetcs/tcga-ov-data/nesutvarkyti failai TCGA-OV analysis/RDS files/train_count_matrix.RDS")
str(data)
pheno <- read.csv("C:/Users/Ieva/Desktop/NVI GDL/R projetcs/tcga-ov-data/nesutvarkyti failai TCGA-OV analysis/CSV files/train_data.csv", header = T)
rownames(pheno) <- pheno$barcode
```
## 1. TCGA-OV mRNA RNAseq counts data taken from earlier analysis
The purpose of this script is to do WGCNA: Weighted correlation network analysis on TCGA-OV mRNA counts. The correlated gene clusters (called colors) are then tested for association with clinical data. I chose figo status and vital status as the most informative clinical features of the TCGA-OV dataset. The two most significantly associated clusters for each clinical trait then were chosen to analyse witch genes are included in the clusters. An elastic-net model was ten applied to the subsection of the cluster associated with the vital status to select the most associated genes.

# 2. QC - outlier detection 
```{r}

# detect outlier genes
#finds outliers rows samples, colums genes, t for transposing
gsg <- goodSamplesGenes(t(data)) 
summary(gsg) #weather there are outliers
gsg$allOK #fals tells there are outliers

table(gsg$goodGenes) #false is the number of outliers
table(gsg$goodSamples)

# remove genes that are detectd as outliers
data <- data[gsg$goodGenes == TRUE,]

```
```{r, out.width="150%", out.height="50%"}
# detect outlier samples - hierarchical clustering - method 1
htree <- hclust(dist(t(data)), method = "average")

plot(htree) #dstant samples should be excluded #save portrait 20x66 inch pdf
```

```{r}
# pca - method 2
pca <- prcomp(t(data))
pca.dat <- pca$x #x is information abouth principal components

pca.var <- pca$sdev^2 #variance explained by principal  components
pca.var.percent <- round(pca.var/sum(pca.var)*100, digits = 2) 
#percentage of the variance explained

pca.dat <- as.data.frame(pca.dat)

ggplot(pca.dat, aes(PC1, PC2)) +
  geom_point() +
  geom_text(label = rownames(pca.dat)) +
  labs(x = paste0('PC1: ', pca.var.percent[1], ' %'),
       y = paste0('PC2: ', pca.var.percent[2], ' %'))
#pasirinksiu nutolusius
```
```{r}
### NOTE: If there are batch effects observed, correct for them before moving ahead

# exclude outlier samples
samples.to.be.excluded <- c('TCGA-29-1699-01A-01R-1567-13', 
                            'TCGA-10-0934-01A-02R-1564-13',
                            'TCGA-13-0899-01A-01R-1564-13',
                            "TCGA-10-0926-01A-01R-1564-13",
                            "TCGA-23-1027-01A-02R-1564-13",
                            "TCGA-10-0931-01A-01R-1564-13",
                            "TCGA-13-0919-01A-01R-1564-13",
                            "TCGA-24-1845-01A-01R-1567-13",
                            "TCGA-13-1482-01A-01R-1565-13",
                            "TCGA-24-1428-01A-01R-1564-13",
                            "TCGA-13-0760-01A-01R-1564-13")
data.subset <- data[,!(colnames(data) %in% samples.to.be.excluded)]

# exclude outlier samples
colData <- pheno %>% 
  filter(!row.names(.) %in% samples.to.be.excluded)

all(rownames(colData) %in% colnames(data.subset))
nrow(colData) == ncol(data.subset)
all(rownames(colData) == colnames(data.subset)) #reikia reagangint
order <- colnames(data.subset)
colData <- colData[match(order, colData$barcode), ] 
all(rownames(colData) == colnames(data.subset)) #reikia reagangint
```
# 3. DESEq2 noramalization, but without any model
```{r}
# making the rownames and column names identical

# create dds
dds <- DESeqDataSetFromMatrix(countData = data.subset,
                              colData = colData,
                              design = ~ 1) # not spcifying model

## remove all genes with counts < 15 in more than 75% of samples (338*0.75=253)
## suggested by WGCNA on RNAseq FAQ

dds75 <- dds[rowSums(counts(dds) >= 15) >= 254,] #237
nrow(dds75) # 13284 genes


# perform variance stabilization
dds_norm <- vst(dds75)


# get normalized counts
norm.counts <- assay(dds_norm) %>% 
  t()

```

# 4. Network Construction
```{r, eval = FALSE}
# Choose a set of soft-thresholding powers
power <- c(c(1:10), seq(from = 12, to = 50, by = 2))

# Call the network topology analysis function
#stf runs quite slow!
sft <- pickSoftThreshold(norm.counts,
                         powerVector = power,
                         networkType = "signed",
                         verbose = 5)
saveRDS(sft, "sft.RDS")
```
```{r}
sft <- readRDS("sft.RDS")
#ziurim max r square ir minimum mean conectivity

sft.data <- sft$fitIndices

# visualization to pick power

a1 <- ggplot(sft.data, aes(Power, SFT.R.sq, label = Power)) +
  geom_point() +
  geom_text(nudge_y = 0.1) +
  geom_hline(yintercept = 0.8, color = 'red') +
  labs(x = 'Power', y = 'Scale free topology model fit, signed R^2') +
  theme_classic()


a2 <- ggplot(sft.data, aes(Power, mean.k., label = Power)) +
  geom_point() +
  geom_text(nudge_y = 0.1) +
  labs(x = 'Power', y = 'Mean Connectivity') +
  theme_classic()

grid.arrange(a1, a2, nrow = 2) #library gridExtra
#choose above red line (above 0.8) and low conectivity (low point on the 2nd plot)
```

choosing 6 as my power from the graph
```{r, eval = FALSE}
#do not run again! bwnet construction can take hours and needs all the memory

# convert matrix to numeric
norm.counts[] <- sapply(norm.counts, as.numeric) #reik šitu dalyku po to esančiai eilutei 

soft_power <- 6
temp_cor <- cor #cor function pasirinkti kitaip namespace error bus
cor <- WGCNA::cor #naudosim sita


# memory estimate w.r.t blocksize
bwnet <- blockwiseModules(norm.counts,
                          maxBlockSize = 18000, #for fast clustering: how many genes in a block, visi genai viename bloke
                          TOMType = "signed",
                          power = soft_power,
                          mergeCutHeight = 0.25,
                          numericLabels = FALSE,
                          randomSeed = 1234,
                          verbose = 3)

saveRDS(bwnet, "bwnet.RDS") 
#a save is necessary because bwnet can run for hours and then quit because of memory issues
cor <- temp_cor #sugražinam
```
eigengene is gene expression profile of a cluster: get profiles for each "color"/cluster
```{r}
bwnet <- readRDS("bwnet.RDS")
# 5. Module Eigengenes ---------------------------------------------------------
module_eigengenes <- bwnet$MEs #MEs yra module egenges


# Print out a preview
head(module_eigengenes) #clusters are colors


# get number of genes for each module
table(bwnet$colors) 
```
Dendogram with all the "colors" (clusters)
```{r}
# Plot the dendrogram and the module colors before and after merging underneath
plotDendroAndColors(bwnet$dendrograms[[1]], cbind(bwnet$unmergedColors, bwnet$colors),
                    c("unmerged", "merged"),
                    dendroLabels = FALSE,
                    addGuide = TRUE,
                    hang= 0.03,
                    guideHang = 0.05)
#kazkodel spalvu nedaro
#merged turi maŽiau spalvu
```
# 5. After unsupervised clustering: Relate modules to traits 
pasirinkame traits! šiuo atveju dead/alive ir figo stage
```{r}
# create traits file - binarize categorical variables
traits <- colData %>% 
  mutate(vital_status_bin = ifelse(grepl('Dead', vital_status), 1, 0)) %>% 
  dplyr::select(48) #select the new colum

#for figo stage, padaryti palyginimą tarp visų galimų stadijų
severity.out <- binarizeCategoricalColumns(colData$figo_stage,
                                           includePairwise = FALSE,
                                           includeLevelVsAll = TRUE,
                                           minCount = 1)
traits <- cbind(traits, severity.out)
```

```{r}
# Define numbers of genes and samples
nSamples <- nrow(norm.counts)
nGenes <- ncol(norm.counts)
#find corelation between eigengenes
module.trait.corr <- cor(module_eigengenes, traits, use = 'p') #pearson cor between eigengenes and traits
module.trait.corr.pvals <- corPvalueStudent(module.trait.corr, nSamples) #cor p values
```
a heatmap between eigengenes and chosen traits
```{r, out.height="50000%"}
heatmap.data <- merge(module_eigengenes, traits, by = 'row.names') #combine  to data frame

colnames(heatmap.data)

heatmap.data <- heatmap.data %>% 
  column_to_rownames(var = 'Row.names') #first colum negali buti numeric todel convertuojam i rownames


CorLevelPlot(heatmap.data,
             x = names(heatmap.data)[102:109], #CLINICAL
             y = names(heatmap.data)[1:101], #"COLORS"
             col = c("blue1", "skyblue", "white", "pink", "red"))
#maybe open separately 20X45inch portrait as there are a 101 eigengenes :)
#significance denoted by *
```
for the most significant modules extract genes: renkuosi vital status ir stage 4
```{r}
module.gene.mapping <- as.data.frame(bwnet$colors) #modules stored as colors

mgmVITAL <- module.gene.mapping %>% 
  filter(`bwnet$colors` == "darkorange") %>% 
  rownames() #filtruosim genus kurie yra musu norimos "spalvos" 

mgmSTAGE4 <- module.gene.mapping %>% 
  filter(`bwnet$colors` == 'thistle1') %>% 
  rownames() #filtruosim genus kurie yra musu norimos "spalvos" 
```
# 6. Intramodular analysis: Identifying driver genes

Calculate the module membership and the associated p-values
The module membership/intramodular connectivity is calculated as the correlation of the eigengene and the gene expression profile. This quantifies the similarity of all genes on the array to every module.
```{r}
#Identifying driver genes
module.membership.measure <- cor(module_eigengenes, norm.counts, use = 'p')
module.membership.measure.pvals <- corPvalueStudent(module.membership.measure, nSamples)
```
Calculate the gene association significance with traits and associated p-values

## 1. vital status
```{r}
gene.signf.corr.vital <- cor(norm.counts, traits$vital_status_bin, use = 'p')
gene.signf.corr.pvals.vital <- corPvalueStudent(gene.signf.corr.vital, nSamples)
ensembl.ids.vital <- gene.signf.corr.pvals.vital %>% 
  as.data.frame() %>% 
  arrange(V1) %>% 
  head(25) %>% 
  rownames()
ensembl.ids.vital
```
## 2. stage IV vs the others
```{r}
gene.signf.corr.stage4 <- cor(norm.counts, traits$`data.Stage IV.vs.all`, use = 'p')
gene.signf.corr.pvals.stage4 <- corPvalueStudent(gene.signf.corr.stage4, nSamples)
ensembl.ids.stage4 <- gene.signf.corr.pvals.stage4 %>% 
  as.data.frame() %>% 
  arrange(V1) %>% 
  head(25) %>% 
  rownames()
ensembl.ids.stage4
```
# 7. Retreve gene names for selected genes
For the transcripts, I wanna retrieve only the gene IDS

## 7.1. vital status

```{r}
#convert relavant gene names
relevant_genes_vital <- gsub("\\..*", "", ensembl.ids.vital)
#biomart
ensembl.ids <- as.data.frame(relevant_genes_vital)
listEnsembl() #shows available databases
ensembl <- useEnsembl(biomart = "genes") #unsuportive gali but
datasets <- listDatasets(ensembl) #issirinkti human genes

ensembl.con <- useMart("ensembl", dataset = 'hsapiens_gene_ensembl') #name of data base ir data set

attr <- listAttributes(ensembl.con)
filters <- listFilters(ensembl.con)

vital <- getBM(attributes = c('ensembl_gene_id','external_gene_name'), #values to retreve
      filters = "ensembl_gene_id", #input on quary
      values = relevant_genes_vital,
      mart = ensembl.con) #sukurtas conection object
vital
```
## 7.2. stage IV vs the others
```{r}
gene.signf.corr.stage4 <- cor(norm.counts, traits$`data.Stage IV.vs.all`, use = 'p')
gene.signf.corr.pvals.stage4 <- corPvalueStudent(gene.signf.corr.stage4, nSamples)
ensembl.ids.stage4 <- gene.signf.corr.pvals.stage4 %>% 
  as.data.frame() %>% 
  arrange(V1) %>% 
  head(25) %>% #pasirenki kiek max genu nori! 
  rownames()
ensembl.ids.stage4
```

```{r}
#convert relavant gene names
relevant_genes_stage <- gsub("\\..*", "", ensembl.ids.stage4)
#biomart
ensembl.ids.stage <- as.data.frame(relevant_genes_stage)

stage <- getBM(attributes = c('ensembl_gene_id','external_gene_name'), #values to retreve
      filters = "ensembl_gene_id", #input on quary
      values = ensembl.ids.stage,
      mart = ensembl.con) #sukurtas conection object
stage
```
# 8. Venn of the lists 

there should be no interesct as these are from diferrrent clusters 
```{r}
transcript.list <- list(fifo4 = relevant_genes_stage,
                        vital_statuts = relevant_genes_vital)
venn(transcript.list)
intersect(relevant_genes_stage, relevant_genes_vital) #no same genes
```
save lists!
```{r}
write.csv(stage, "stage_cluster_genes.csv")
write.csv(vital, "vital_cluster_genes.csv")
```
# 9. GO? gene annotation
```{r}
stage.GO <- getBM(attributes = c('ensembl_gene_id','external_gene_name', "go_id"), #values to retreve
      filters = "ensembl_gene_id", #input on quary
      values = ensembl.ids.stage,
      mart = ensembl.con) #sukurtas conection object
head(stage.GO) #makes a huuuudge list because every gene has lots of GO_ids
```
```{r}
vital.GO <- getBM(attributes = c('ensembl_gene_id','external_gene_name', "go_id"), #values to retreve
      filters = "ensembl_gene_id", #input on quary
      values = relevant_genes_vital,
      mart = ensembl.con) #sukurtas conection object
head(vital.GO) #makes a huuuudge list because every gene has lots of GO_ids
```
 save lists!
```{r}
write.csv(stage.GO, "stage_cluster_genesGO.csv")
write.csv(vital.GO, "vital_cluster_genesGO.csv")
```
## GO bet su reikšmėm: vital
```{r}
#from org.Hs.eg.db
vital.symbols <- vital$external_gene_name
vital.entrez <- mapIds(org.Hs.eg.db, vital.symbols, 'ENTREZID', 'SYMBOL')
#names chr vector of entrez ids

ggo.vital <- groupGO(gene = vital.entrez,
               OrgDb    = org.Hs.eg.db,
               ont      = "CC",
               level    = 3,
               readable = TRUE)

head(ggo.vital) # count is 0 because i provided no counts!
ggo.vital_df <- as.data.frame(ggo.vital)
ggo.vital_df_filtered <- ggo.vital_df %>% filter(Count != "0")
ggo.vital_df_filtered
```
```{r}
#ego = enrichment go
ego.vital <- enrichGO(gene          = vital.entrez,
                OrgDb         = org.Hs.eg.db,
                ont           = "CC",
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
        readable      = TRUE)
as.data.frame(ego.vital)
goplot(ego.vital)
```

## GO bet su reikšmėm: stage
```{r}
#from org.Hs.eg.db
stage.symbols <- stage$external_gene_name
stage.entrez <- mapIds(org.Hs.eg.db, stage.symbols, 'ENTREZID', 'SYMBOL')
#names chr vector of entrez ids

ggo.stage <- groupGO(gene = stage.entrez,
               OrgDb    = org.Hs.eg.db,
               ont      = "CC",
               level    = 3,
               readable = TRUE)

head(ggo.stage) # count is 0 because i provided no counts!
ggo.stage_df <- as.data.frame(ggo.stage)
ggo.stage_df_filtered <- ggo.stage_df %>% filter(Count != "0")
ggo.stage_df_filtered
```
```{r}
#ego = enrichment go
ego.stage <- enrichGO(gene = stage.entrez,
                OrgDb         = org.Hs.eg.db,
                ont           = "CC",
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
        readable      = TRUE)
as.data.frame(ego.stage) # nothing is enriched apparantly in stage

```
# 10. How is it diferrent from the elastic net?

First I construct the model without any clustering.
I will be using the same data, that was normalized and filtered in this analysis
```{r}
#using norm.counts
#clinical feature:vital_status
train_response <- as.factor(colData$vital_status)
res_vital = cv.glmnet(
  x = norm.counts,
  y = train_response,
  alpha = 0.5,
  family = "binomial"
)
#skip testing model, requires test data
# Getting genes that contribute for the prediction
res_coef_vital = coef(res_vital, s="lambda.min") # the "coef" function returns a sparse matrix
head(res_coef_vital) # in a sparse matrix the "." represents the value of zero
# get coefficients with non-zero values
res_coef_vital = res_coef_vital[res_coef_vital[,1] != 0,] 
# note how performing this operation changed the type of the variable
# remove first coefficient as this is the intercept, a variable of the model itself
res_coef_vital = res_coef_vital[-1]
relevant_genes_vital_from_cluster = names(res_coef_vital) # get names of the (non-zero) variables.
length(relevant_genes_vital_from_cluster) # number of selected genes #4 lambda min, ir #0 genes with 1SE

#convert relavant gene names
relevant_genes_cluster_vital <- gsub("\\..*", "",relevant_genes_vital_from_cluster)
relevant_genes_cluster_vital
#biomart
vital.4 <- getBM(attributes = c('ensembl_gene_id','external_gene_name'), #values to retreve
      filters = "ensembl_gene_id", #input on quary
      values = relevant_genes_cluster_vital,
      mart = ensembl.con) #sukurtas conection object
vital.4
```
okay I have 4 genes associated with vital status. what do they do?
```{r}
#from org.Hs.eg.db
vital4.symbols <- vital.4$external_gene_name
vital4.entrez <- mapIds(org.Hs.eg.db, vital4.symbols, 'ENTREZID', 'SYMBOL')
#names chr vector of entrez ids
ggo.vital4 <- groupGO(gene = vital4.entrez,
               OrgDb    = org.Hs.eg.db,
               ont      = "CC",
               level    = 3,
               readable = TRUE)

ggo.vital4 <- as.data.frame(ggo.vital4) # count is 0 because i provided no counts!
ggo.vital4_filt <- ggo.vital4 %>% filter(Count != "0")
ggo.vital4_filt
```
## VENN elastic net vs the WGCNE main cluster
```{r}
library(ggvenn)
library(RColorBrewer)
gene.list_vital <- list(elasticnet_Vital = vital4.symbols,
                        WGCNA_Vital = vital.symbols)
ggvenn(gene.list_vital, show_elements = T, label_sep = "\n", fill_color = brewer.pal(name="Set2",n=2))
```
Taigi best pagal training data genai yra:
CD38,MZB1, SLAMF7 - "CD319", IKZF3 - "Ikaros" - imuniniai žymenys kaip suprantu iš GO ir quick  google. 

## Venn of elastic vs wgcne 2
Ar Elasticnet tiesiog pasirinka tuos pačius top 4 genus iš mano "tamsiai oranžinio"/vital genų sąrašo?
```{r}
#grįžtu prie genu atrinkimo
ensembl.ids.vital4 <- gene.signf.corr.pvals.vital %>% 
  as.data.frame() %>% 
  arrange(V1) %>% 
  head(4) %>% #kadangi čia pasirenki kiek top genu nori, davai 4 noriu palygint
  rownames()
ensembl.ids.vital4 %in% relevant_genes_vital_from_cluster 
vital3 <- intersect(ensembl.ids.vital4,relevant_genes_vital_from_cluster)
vital3 <- gsub("\\..*", "",vital3)
#biomart
vital3 <- getBM(attributes = c('ensembl_gene_id','external_gene_name'), 
      filters = "ensembl_gene_id", #input on quary
      values = vital3,
      mart = ensembl.con) #sukurtas conection object
vital3
```
Yes, 3/4 genų yra tie patys tarp top WGCNE ir elastic net

## Venn of elastic vs wgcne 3
O kas jei elastic net leisiu rinktis tik iš "tamsiai oranžinio"/vital WGCNE genų sąrašo? 
```{r}
#kiek genu buvo pilnai spalvoj mano?
colornumbers <- as.data.frame(table(bwnet$colors))
colornumbers[20, ]
#tam reikia original ENSEMBLE transcriptu ids sąrašo, bet tik pasirinkto klasterio
ensembl.ids.vital_FULL <- gene.signf.corr.pvals.vital %>% 
  as.data.frame() %>% 
  arrange(V1) %>% 
  head(56) %>% #cia isiraso nr
  rownames()

norm.countsW <- norm.counts[,(colnames(norm.counts) %in% ensembl.ids.vital_FULL)]
dim(norm.countsW) #liko 56 genai, 338 samplai todėl nereikia keisti colData

res_vitalW = cv.glmnet(
  x = norm.countsW,
  y = train_response,
  alpha = 0.5,
  family = "binomial"
)
res_vitalW 
```
Sumažinus genų sąrašą pasirenka net 12 genų? let's see them

```{r}
# Getting genes that contribute for the prediction
res_coef_vitalW = coef(res_vitalW, s="lambda.min") # the "coef" function returns a sparse matrix
# get coefficients with non-zero values
res_coef_vitalW = res_coef_vitalW[res_coef_vitalW[,1] != 0,] 
# note how performing this operation changed the type of the variable
# remove first coefficient as this is the intercept, a variable of the model itself
res_coef_vitalW = res_coef_vitalW[-1]
relevant_genes_vitalW= names(res_coef_vitalW) # get names of the (non-zero) variables.
length(relevant_genes_vitalW) # number of selected genes #4 lambda min, ir #0 genes with 1SE

#convert relavant gene names
relevant_genes_vitalW <- gsub("\\..*", "",relevant_genes_vitalW)
relevant_genes_vitalW
#biomart
vital.12 <- getBM(attributes = c('ensembl_gene_id','external_gene_name'), #values to retreve
      filters = "ensembl_gene_id", #input on quary
      values = relevant_genes_vitalW,
      mart = ensembl.con) #sukurtas conection object
vital.12
```
neatrodo tie patys kažkaip, let's test
```{r}
vital.12 <- vital.12$external_gene_name
list_vitals <- list(vital.12 = vital.12, elasticnet_Vital = vital4.symbols,
                        WGCNA_Vital = vital.symbols)
venn(list_vitals) #persikloja
```
kai kas persikloja, rankam kas:
1. elastic net is tamsiai oranzinio kasterio vs eltastic net is visu (12 vs 4)
```{r}
intersect(vital.12, vital4.symbols)
```
2. elastic net is tamsiai oranzinio kasterio vs wgcne tamsiai oranzinis (12 vs 56)
```{r}
#neturiu dar pilno genu saraso visiems 56 tamsiai oranziniam genams
#convert relavant gene names
relevant_genes_vital56 <- gsub("\\..*", "",ensembl.ids.vital_FULL)
relevant_genes_vital56
#biomart
vital.56 <- getBM(attributes = c('ensembl_gene_id','external_gene_name'), #values to retreve
      filters = "ensembl_gene_id", #input on quary
      values = relevant_genes_vital56,
      mart = ensembl.con) #sukurtas conection object
vital.56
vital.56 <- vital.56$external_gene_name

intersect(vital.12, vital.56)

```
tu 12 ir 56 sutampantys, kurie sutampa su tais 4 is elastic net 1 modelio:
```{r}
vital12_56 <- intersect(vital.12, vital.56)
intersect(vital4.symbols, vital12_56)
```
Labiausiai IKZF3 ir MZB1 siejasi su vital status




